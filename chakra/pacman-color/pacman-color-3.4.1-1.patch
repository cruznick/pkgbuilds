diff -Naur pacman-3.4.1//src/pacman/callback.c pacman-color-3.4.1//src/pacman/callback.c
--- pacman-3.4.1//src/pacman/callback.c	2010-07-03 01:23:20.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/callback.c	2010-09-12 09:56:57.180000001 +0200
@@ -218,16 +218,16 @@
 			printf(_("generating %s with %s... "), (char *)data1, (char *)data2);
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_DONE:
-			printf(_("success!\n"));
+			color_printf(COLOR_GREEN_ALL, _("success!\n"));
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_FAILED:
-			printf(_("failed.\n"));
+			color_printf(COLOR_RED_ALL, _("failed.\n"));
 			break;
 		case PM_TRANS_EVT_SCRIPTLET_INFO:
 			printf("%s", (char*)data1);
 			break;
 		case PM_TRANS_EVT_RETRIEVE_START:
-			printf(_(":: Retrieving packages from %s...\n"), (char*)data1);
+			color_printf(COLOR_DOUBLECOLON, _(":: Retrieving packages from %s...\n"), (char*)data1);
 			break;
 		/* all the simple done events, with fallthrough for each */
 		case PM_TRANS_EVT_FILECONFLICTS_DONE:
@@ -250,11 +250,11 @@
 {
 	switch(event) {
 		case PM_TRANS_CONV_INSTALL_IGNOREPKG:
-			*response = yesno(_(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
 							  alpm_pkg_get_name(data1));
 			break;
 		case PM_TRANS_CONV_REPLACE_PKG:
-			*response = yesno(_(":: Replace %s with %s/%s?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: Replace %s with %s/%s?"),
 					alpm_pkg_get_name(data1),
 					(char *)data3,
 					alpm_pkg_get_name(data2));
@@ -263,12 +263,12 @@
 			/* data parameters: target package, local package, conflict (strings) */
 			/* print conflict only if it contains new information */
 			if(!strcmp(data1, data3) || !strcmp(data2, data3)) {
-				*response = noyes(_(":: %s and %s are in conflict. Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict. Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data2);
 			} else {
-				*response = noyes(_(":: %s and %s are in conflict (%s). Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s). Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data3,
@@ -283,17 +283,17 @@
 					namelist = alpm_list_add(namelist,
 							(char *)alpm_pkg_get_name(i->data));
 				}
-				printf(_(":: the following package(s) cannot be upgraded due to "
+				color_printf(COLOR_DOUBLECOLON, _(":: the following package(s) cannot be upgraded due to "
 						"unresolvable dependencies:\n"));
-				list_display("     ", namelist);
-				*response = noyes(_("\nDo you want to skip the above "
+				list_display(NULL, "     ", namelist);
+				*response = noyes(NULL, _("\nDo you want to skip the above "
 							"package(s) for this upgrade?"));
 				alpm_list_free(namelist);
 			}
 			break;
 		case PM_TRANS_CONV_LOCAL_NEWER:
 			if(!config->op_s_downloadonly) {
-				*response = yesno(_(":: %s-%s: local version is newer. Upgrade anyway?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: %s-%s: local version is newer. Upgrade anyway?"),
 						alpm_pkg_get_name(data1),
 						alpm_pkg_get_version(data1));
 			} else {
@@ -301,7 +301,7 @@
 			}
 			break;
 		case PM_TRANS_CONV_CORRUPTED_PKG:
-			*response = yesno(_(":: File %s is corrupted. Do you want to delete it?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: File %s is corrupted. Do you want to delete it?"),
 					(char *)data1);
 			break;
 	}
@@ -421,8 +421,8 @@
 
 	}
 
-	printf("(%*d/%*d) %ls%-*s", digits, remain, digits, howmany,
-			wcstr, padwid, "");
+	color_printf(COLOR_BLUE_ALL, "(%*d/%*d)", digits, remain, digits, howmany);
+	printf(" %ls%-*s", wcstr, padwid, "");
 
 	free(wcstr);
 
diff -Naur pacman-3.4.1//src/pacman/package.c pacman-color-3.4.1//src/pacman/package.c
--- pacman-3.4.1//src/pacman/package.c	2010-07-03 01:23:20.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/package.c	2010-09-12 09:56:57.180000001 +0200
@@ -91,47 +91,47 @@
 	}
 
 	/* actual output */
-	string_display(_("Name           :"), alpm_pkg_get_name(pkg));
-	string_display(_("Version        :"), alpm_pkg_get_version(pkg));
-	string_display(_("URL            :"), alpm_pkg_get_url(pkg));
-	list_display(_("Licenses       :"), alpm_pkg_get_licenses(pkg));
-	list_display(_("Groups         :"), alpm_pkg_get_groups(pkg));
-	list_display(_("Provides       :"), alpm_pkg_get_provides(pkg));
-	list_display(_("Depends On     :"), depstrings);
-	list_display_linebreak(_("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Name           :"), COLOR_WHITE_ALL, alpm_pkg_get_name(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Version        :"), COLOR_GREEN_ALL, alpm_pkg_get_version(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("URL            :"), COLOR_CYAN_ALL, alpm_pkg_get_url(pkg));
+	list_display(COLOR_WHITE_ALL, _("Licenses       :"), alpm_pkg_get_licenses(pkg));
+	list_display(COLOR_WHITE_ALL, _("Groups         :"), alpm_pkg_get_groups(pkg));
+	list_display(COLOR_WHITE_ALL, _("Provides       :"), alpm_pkg_get_provides(pkg));
+	list_display(COLOR_WHITE_ALL, _("Depends On     :"), depstrings);
+	list_display_linebreak(COLOR_WHITE_ALL, _("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
 	if(level > 0 || level < -1) {
-		list_display(_("Required By    :"), requiredby);
+		list_display(COLOR_WHITE_ALL, _("Required By    :"), requiredby);
 	}
-	list_display(_("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
-	list_display(_("Replaces       :"), alpm_pkg_get_replaces(pkg));
+	list_display(COLOR_WHITE_ALL, _("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
+	list_display(COLOR_WHITE_ALL, _("Replaces       :"), alpm_pkg_get_replaces(pkg));
 	if(level < 0) {
-		printf(_("Download Size  : %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Download Size  : %6.2f K\n"),
 			(float)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 	if(level == 0) {
-		printf(_("Compressed Size: %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Compressed Size: %6.2f K\n"),
 			(float)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 
-	printf(_("Installed Size : %6.2f K\n"),
+	color_printf(COLOR_WHITE_COLON, _("Installed Size : %6.2f K\n"),
 			(float)alpm_pkg_get_isize(pkg) / 1024.0);
-	string_display(_("Packager       :"), alpm_pkg_get_packager(pkg));
-	string_display(_("Architecture   :"), alpm_pkg_get_arch(pkg));
-	string_display(_("Build Date     :"), bdatestr);
+	string_display(COLOR_WHITE_ALL, _("Packager       :"), alpm_pkg_get_packager(pkg));
+	string_display(COLOR_WHITE_ALL, _("Architecture   :"), alpm_pkg_get_arch(pkg));
+	string_display(COLOR_WHITE_ALL, _("Build Date     :"), bdatestr);
 	if(level > 0) {
-		string_display(_("Install Date   :"), idatestr);
-		string_display(_("Install Reason :"), reason);
+		string_display(COLOR_WHITE_ALL, _("Install Date   :"), idatestr);
+		string_display(COLOR_WHITE_ALL, _("Install Reason :"), reason);
 	}
 	if(level >= 0) {
-		string_display(_("Install Script :"),
+		string_display(COLOR_WHITE_ALL, _("Install Script :"),
 				alpm_pkg_has_scriptlet(pkg) ?  _("Yes") : _("No"));
 	}
 
 	/* MD5 Sum for sync package */
 	if(level < 0) {
-		string_display(_("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
+		string_display(COLOR_WHITE_ALL, _("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
 	}
-	string_display(_("Description    :"), alpm_pkg_get_desc(pkg));
+	string_display(COLOR_WHITE_ALL, _("Description    :"), alpm_pkg_get_desc(pkg));
 
 	/* Print additional package info if info flag passed more than once */
 	if(level > 1) {
@@ -152,7 +152,7 @@
 	if(pkg == NULL) {
 		return;
 	}
-	string_display(_("Repository     :"), treename);
+	color_string_display(COLOR_WHITE_ALL, _("Repository     :"), COLOR_MAGENTA_ALL, treename);
 	/* invert the level since we are a sync package */
 	dump_pkg_full(pkg, -level);
 }
@@ -163,7 +163,7 @@
 {
 	alpm_list_t *i;
 	const char *root = alpm_option_get_root();
-	printf(_("Backup Files:\n"));
+	color_printf(COLOR_WHITE_ALL, _("Backup Files:\n"));
 	if(alpm_pkg_get_backup(pkg)) {
 		/* package has backup files, so print them */
 		for(i = alpm_pkg_get_backup(pkg); i; i = alpm_list_next(i)) {
@@ -190,13 +190,13 @@
 
 				/* if checksums don't match, file has been modified */
 				if (strcmp(md5sum, ptr)) {
-					printf(_("MODIFIED\t%s\n"), path);
+					color_printf(COLOR_YELLOW_ALL, _("MODIFIED\t%s\n"), path);
 				} else {
-					printf(_("Not Modified\t%s\n"), path);
+					color_printf(COLOR_GREEN_ALL, _("Not Modified\t%s\n"), path);
 				}
 				free(md5sum);
 			} else {
-				printf(_("MISSING\t\t%s\n"), path);
+				color_printf(COLOR_RED_ALL, _("MISSING\t\t%s\n"), path);
 			}
 			free(str);
 		}
@@ -220,7 +220,8 @@
 	for(i = pkgfiles; i; i = alpm_list_next(i)) {
 		filestr = alpm_list_getdata(i);
 		if(!quiet){
-			fprintf(stdout, "%s %s%s\n", pkgname, root, filestr);
+			color_fprintf(stdout, COLOR_WHITE_ALL, "%s", pkgname);
+			fprintf(stdout, " %s%s\n", root, filestr);
 		} else {
 			fprintf(stdout, "%s%s\n", root, filestr);
 		}
diff -Naur pacman-3.4.1//src/pacman/pacman.c pacman-color-3.4.1//src/pacman/pacman.c
--- pacman-3.4.1//src/pacman/pacman.c	2010-07-03 01:23:20.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/pacman.c	2010-09-12 09:56:57.183333335 +0200
@@ -174,11 +174,22 @@
  */
 static void version(void)
 {
-	printf("\n");
-	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
-	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2010 Pacman Development Team\n");
-	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
-	printf(" '--'\n");
+	color_printf(COLOR_YELLOW_ALL, " .--. ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, " .---. ");
+	printf("  Pacman-color v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	color_printf(COLOR_YELLOW_ALL, "/ _.-'");
+	color_printf(COLOR_WHITE_ALL, " .-.  .-");
+	color_printf(COLOR_RED_ALL, "|O O  |");
+	printf("  Copyright (C) 2006-2010 Pacman Development Team\n");
+	color_printf(COLOR_YELLOW_ALL, "\\  '-.");
+	color_printf(COLOR_WHITE_ALL, " '-'  '-");
+	color_printf(COLOR_RED_ALL, "|~~~  |");
+	printf("  Copyright (C) 2002-2006 Judd Vinet\n");
+	color_printf(COLOR_YELLOW_ALL, " '--' ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, "|.-.-.|");
+	printf("  Colored by vogo <vogo(at)seznam(dot)cz>\n");
 	printf(_("                       This program may be freely redistributed under\n"
 	         "                       the terms of the GNU General Public License.\n"));
 	printf("\n");
@@ -1125,6 +1136,7 @@
 
 	/* init config data */
 	config = config_new();
+	parsecolorconfig();
 
 	/* disable progressbar if the output is redirected */
 	if(!isatty(1)) {
@@ -1196,17 +1208,17 @@
 
 	if(config->verbose > 0) {
 		alpm_list_t *i;
-		printf("Root      : %s\n", alpm_option_get_root());
-		printf("Conf File : %s\n", config->configfile);
-		printf("DB Path   : %s\n", alpm_option_get_dbpath());
-		printf("Cache Dirs: ");
+		string_display(COLOR_WHITE_ALL, "Root      :", alpm_option_get_root());
+		string_display(COLOR_WHITE_ALL, "Conf File :", config->configfile);
+		string_display(COLOR_WHITE_ALL, "DB Path   :", alpm_option_get_dbpath());
+		color_printf(COLOR_WHITE_ALL, "Cache Dirs: ");
 		for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
 			printf("%s  ", (char*)alpm_list_getdata(i));
 		}
 		printf("\n");
-		printf("Lock File : %s\n", alpm_option_get_lockfile());
-		printf("Log File  : %s\n", alpm_option_get_logfile());
-		list_display("Targets   :", pm_targets);
+		string_display(COLOR_WHITE_ALL, "Lock File :", alpm_option_get_lockfile());
+		string_display(COLOR_WHITE_ALL, "Log File  :", alpm_option_get_logfile());
+		list_display(COLOR_WHITE_ALL, "Targets   :", pm_targets);
 	}
 
 	/* Opening local database */
diff -Naur pacman-3.4.1//src/pacman/query.c pacman-color-3.4.1//src/pacman/query.c
--- pacman-3.4.1//src/pacman/query.c	2010-06-24 15:23:29.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/query.c	2010-09-12 09:56:57.183333335 +0200
@@ -220,7 +220,9 @@
 		pmpkg_t *pkg = alpm_list_getdata(i);
 
 		if (!config->quiet) {
-			printf("local/%s %s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_MAGENTA_ALL, "local/");
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s", alpm_pkg_get_name(pkg));
 		}
@@ -237,16 +239,11 @@
 		if (!config->quiet) {
 			if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 				alpm_list_t *k;
-				printf(" (");
+				color_printf(COLOR_BLUE_ALL, " (");
 				for(k = grp; k; k = alpm_list_next(k)) {
 					const char *group = alpm_list_getdata(k);
-					printf("%s", group);
-					if(alpm_list_next(k)) {
-						/* only print a spacer if there are more groups */
-						printf(" ");
-					}
+					color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 				}
-				printf(")");
 			}
 
 			/* we need a newline and initial indent first */
@@ -278,7 +275,8 @@
 			packages = alpm_grp_get_pkgs(grp);
 
 			for(p = packages; p; p = alpm_list_next(p)) {
-				printf("%s %s\n", grpname, alpm_pkg_get_name(alpm_list_getdata(p)));
+				color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+				color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 			}
 		}
 	} else {
@@ -290,8 +288,8 @@
 				const alpm_list_t *p, *packages = alpm_grp_get_pkgs(grp);
 				for(p = packages; p; p = alpm_list_next(p)) {
 					if(!config->quiet) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(p)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					} else {
 						printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					}
@@ -437,7 +435,8 @@
 	if(!config->op_q_info && !config->op_q_list
 			&& !config->op_q_changelog && !config->op_q_check) {
 		if (!config->quiet) {
-			printf("%s %s\n", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s\n", alpm_pkg_get_name(pkg));
 		}
diff -Naur pacman-3.4.1//src/pacman/remove.c pacman-color-3.4.1//src/pacman/remove.c
--- pacman-3.4.1//src/pacman/remove.c	2010-06-24 15:23:29.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/remove.c	2010-09-12 09:56:57.186666669 +0200
@@ -79,7 +79,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -87,7 +87,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -110,7 +110,7 @@
 			holdpkg = 1;
 		}
 	}
-	if(holdpkg && (noyes(_("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
+	if(holdpkg && (noyes(NULL, _("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
 		retval = 1;
 		goto cleanup;
 	}
@@ -130,7 +130,7 @@
 	/* print targets and ask user confirmation */
 	display_targets(pkglist, 0);
 	printf("\n");
-	if(yesno(_("Do you want to remove these packages?")) == 0) {
+	if(yesno(NULL, _("Do you want to remove these packages?")) == 0) {
 		retval = 1;
 		goto cleanup;
 	}
diff -Naur pacman-3.4.1//src/pacman/sync.c pacman-color-3.4.1//src/pacman/sync.c
--- pacman-3.4.1//src/pacman/sync.c	2010-07-03 01:23:20.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/sync.c	2010-09-12 09:56:57.186666669 +0200
@@ -86,7 +86,7 @@
 		/* We have a directory that doesn't match any syncdb.
 		 * Ask the user if he wants to remove it. */
 		if(!found) {
-			if(!yesno(_("Do you want to remove %s?"), path)) {
+			if(!yesno(NULL, _("Do you want to remove %s?"), path)) {
 				continue;
 			}
 
@@ -108,8 +108,8 @@
 	int ret = 0;
 
 	dbpath = alpm_option_get_dbpath();
-	printf(_("Database directory: %s\n"), dbpath);
-	if(!yesno(_("Do you want to remove unused repositories?"))) {
+	color_printf(COLOR_WHITE_COLON, _("Database directory: %s\n"), dbpath);
+	if(!yesno(NULL, _("Do you want to remove unused repositories?"))) {
 		return(0);
 	}
 	/* The sync dbs were previously put in dbpath/, but are now in dbpath/sync/,
@@ -131,18 +131,18 @@
 	int ret = 0;
 
 	for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
-		printf(_("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
+		color_printf(COLOR_WHITE_COLON, _("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
 	}
 
 	if(level == 1) {
 		switch(config->cleanmethod) {
 			case PM_CLEAN_KEEPINST:
-				if(!yesno(_("Do you want to remove uninstalled packages from cache?"))) {
+				if(!yesno(NULL, _("Do you want to remove uninstalled packages from cache?"))) {
 					return(0);
 				}
 				break;
 			case PM_CLEAN_KEEPCUR:
-				if(!yesno(_("Do you want to remove outdated packages from cache?"))) {
+				if(!yesno(NULL, _("Do you want to remove outdated packages from cache?"))) {
 					return(0);
 				}
 				break;
@@ -152,7 +152,7 @@
 		}
 		printf(_("removing old packages from cache...\n"));
 	} else {
-		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+		if(!noyes(NULL, _("Do you want to remove ALL files from cache?"))) {
 			return(0);
 		}
 		printf(_("removing all files from cache...\n"));
@@ -194,7 +194,7 @@
 			 * files here that aren't valid packages. we also don't need a full
 			 * load of the package, just the metadata. */
 			if(alpm_pkg_load(path, 0, &localpkg) != 0 || localpkg == NULL) {
-				if(yesno(_("File %s does not seem to be a valid package, remove it?"), path)) {
+				if(yesno(NULL, _("File %s does not seem to be a valid package, remove it?"), path)) {
 					if(localpkg) {
 						alpm_pkg_free(localpkg);
 					}
@@ -321,8 +321,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-							 alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s/", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 			} else {
 				printf("%s", alpm_pkg_get_name(pkg));
 			}
@@ -338,16 +339,11 @@
 			if (!config->quiet) {
 				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 					alpm_list_t *k;
-					printf(" (");
+					color_printf(COLOR_BLUE_ALL, " (");
 					for(k = grp; k; k = alpm_list_next(k)) {
 						const char *group = alpm_list_getdata(k);
-						printf("%s", group);
-						if(alpm_list_next(k)) {
-							/* only print a spacer if there are more groups */
-							printf(" ");
-						}
+						color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 					}
-					printf(")");
 				}
 
 				print_installed(pkg);
@@ -382,8 +378,8 @@
 					/* get names of packages in group */
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
 						if(!config->quiet) {
-							printf("%s %s\n", grpname,
-									alpm_pkg_get_name(alpm_list_getdata(k)));
+							color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+							color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						} else {
 							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						}
@@ -401,8 +397,8 @@
 
 				if(level > 1) {
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(k)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 					}
 				} else {
 					/* print grp names only, no package names */
@@ -538,8 +534,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s %s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-						alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s ", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 				print_installed(pkg);
 				printf("\n");
 			} else {
@@ -628,7 +625,7 @@
 	}
 
 	if(config->op_s_upgrade) {
-		printf(_(":: Starting full system upgrade...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Starting full system upgrade...\n"));
 		alpm_logaction("starting full system upgrade\n");
 		if(alpm_sync_sysupgrade(config->op_s_upgrade >= 2) == -1) {
 			pm_fprintf(stderr, PM_LOG_ERROR, "%s\n", alpm_strerrorlast());
@@ -646,7 +643,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -654,7 +651,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -667,9 +664,9 @@
 					const char *reason = alpm_conflict_get_reason(conflict);
 					/* only print reason if it contains new information */
 					if(!strcmp(package1, reason) || !strcmp(package2, reason)) {
-						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"), package1, package2);
 					} else {
-						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
 					}
 				}
 				break;
@@ -699,9 +696,9 @@
 
 	int confirm;
 	if(config->op_s_downloadonly) {
-		confirm = yesno(_("Proceed with download?"));
+		confirm = yesno(NULL, _("Proceed with download?"));
 	} else {
-		confirm = yesno(_("Proceed with installation?"));
+		confirm = yesno(NULL, _("Proceed with installation?"));
 	}
 	if(!confirm) {
 		goto cleanup;
@@ -723,7 +720,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
@@ -741,7 +738,7 @@
 				break;
 		}
 		/* TODO: stderr? */
-		printf(_("Errors occurred, no packages were upgraded.\n"));
+		color_printf(COLOR_RED_ALL, _("Errors occurred, no packages were upgraded.\n"));
 		retval = 1;
 		goto cleanup;
 	}
@@ -790,7 +787,7 @@
 
 	if(config->op_s_sync) {
 		/* grab a fresh package list */
-		printf(_(":: Synchronizing package databases...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Synchronizing package databases...\n"));
 		alpm_logaction("synchronizing package lists\n");
 		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
 			return(1);
@@ -839,9 +836,9 @@
 			alpm_list_t *tmp = NULL;
 			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
 				alpm_list_free(tmp);
-				printf(_(":: The following packages should be upgraded first :\n"));
-				list_display("   ", packages);
-				if(yesno(_(":: Do you want to cancel the current operation\n"
+				color_printf(COLOR_DOUBLECOLON, _(":: The following packages should be upgraded first :\n"));
+				list_display(NULL, "   ", packages);
+				if(yesno(COLOR_DOUBLECOLON2, _(":: Do you want to cancel the current operation\n"
 								":: and upgrade these packages now?"))) {
 					FREELIST(targs);
 					targs = packages;
diff -Naur pacman-3.4.1//src/pacman/upgrade.c pacman-color-3.4.1//src/pacman/upgrade.c
--- pacman-3.4.1//src/pacman/upgrade.c	2010-07-03 01:23:20.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/upgrade.c	2010-09-12 09:56:57.186666669 +0200
@@ -88,7 +88,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -100,7 +100,7 @@
 					/* TODO indicate if the error was a virtual package or not:
 					 *		:: %s: requires %s, provided by %s
 					 */
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -113,9 +113,9 @@
 					const char *reason = alpm_conflict_get_reason(conflict);
 					/* only print reason if it contains new information */
 					if(!strcmp(package1, reason) || !strcmp(package2, reason)) {
-						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"), package1, package2);
 					} else {
-						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
 					}
 				}
 				break;
@@ -145,7 +145,7 @@
 	display_targets(alpm_trans_get_remove(), 0);
 	display_targets(alpm_trans_get_add(), 1);
 	printf("\n");
-	int confirm = yesno(_("Proceed with installation?"));
+	int confirm = yesno(NULL, _("Proceed with installation?"));
 	if(!confirm) {
 		trans_release();
 		return(retval);
@@ -167,7 +167,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
diff -Naur pacman-3.4.1//src/pacman/util.c pacman-color-3.4.1//src/pacman/util.c
--- pacman-3.4.1//src/pacman/util.c	2010-07-27 17:10:55.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/util.c	2010-09-12 09:56:57.190000002 +0200
@@ -45,6 +45,20 @@
 #include "conf.h"
 #include "callback.h"
 
+#define COLOR_LEN 8
+
+typedef struct __colortab_t {
+	char red[COLOR_LEN + 1];
+	char green[COLOR_LEN + 1];
+	char yellow[COLOR_LEN + 1];
+	char blue[COLOR_LEN + 1];
+	char magenta[COLOR_LEN + 1];
+	char cyan[COLOR_LEN + 1];
+	char white[COLOR_LEN + 1];
+	char none[COLOR_LEN + 1];
+} colortab_t;
+
+static colortab_t colortab;
 
 int trans_init(pmtransflag_t flags)
 {
@@ -426,12 +440,12 @@
 	return(len);
 }
 
-void string_display(const char *title, const char *string)
+void string_display(const colordata_t *colors_title, const char *title, const char *string)
 {
 	int len = 0;
 
 	if(title) {
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 	if(string == NULL || string[0] == '\0') {
 		printf(_("None"));
@@ -443,14 +457,14 @@
 	printf("\n");
 }
 
-void list_display(const char *title, const alpm_list_t *list)
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int cols, len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -479,14 +493,14 @@
 	}
 }
 
-void list_display_linebreak(const char *title, const alpm_list_t *list)
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -546,21 +560,21 @@
 
 	if(install) {
 		asprintf(&str, _("Targets (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_YELLOW_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Download Size:    %.2f MB\n"), mbdlsize);
+		color_printf(COLOR_WHITE_COLON, _("Total Download Size:    %.2f MB\n"), mbdlsize);
 		if(!(config->flags & PM_TRANS_FLAG_DOWNLOADONLY)) {
-			printf(_("Total Installed Size:   %.2f MB\n"), mbisize);
+			color_printf(COLOR_WHITE_COLON, _("Total Installed Size:   %.2f MB\n"), mbisize);
 		}
 	} else {
 		asprintf(&str, _("Remove (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_RED_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Removed Size:   %.2f MB\n"), mbisize);
+		color_printf(COLOR_WHITE_COLON, _("Total Removed Size:   %.2f MB\n"), mbisize);
 	}
 
 	FREELIST(targets);
@@ -672,7 +686,7 @@
 	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
 	if(optdeps) {
 		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 	alpm_list_free(optdeps);
 }
@@ -682,12 +696,12 @@
 	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
 	if(optdeps) {
 		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 }
 
 /* presents a prompt and gets a Y/N answer */
-static int question(short preset, char *fmt, va_list args)
+static int question(const colordata_t *colors, short preset, char *fmt, va_list args)
 {
 	char response[32];
 	int sresponse = sizeof(response)-1;
@@ -700,7 +714,7 @@
 		stream = stderr;
 	}
 
-	vfprintf(stream, fmt, args);
+	color_vfprintf(stream, colors, fmt, args);
 
 	if(preset) {
 		fprintf(stream, " %s ", _("[Y/n]"));
@@ -728,25 +742,25 @@
 	return(0);
 }
 
-int yesno(char *fmt, ...)
+int yesno(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(1, fmt, args);
+	ret = question(colors, 1, fmt, args);
 	va_end(args);
 
 	return(ret);
 }
 
-int noyes(char *fmt, ...)
+int noyes(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(0, fmt, args);
+	ret = question(colors, 0, fmt, args);
 	va_end(args);
 
 	return(ret);
@@ -792,21 +806,40 @@
 	ret = vasprintf(&msg, format, args);
 
 	/* print a prefix to the message */
-	switch(level) {
-		case PM_LOG_DEBUG:
-			asprintf(string, "debug: %s", msg);
-			break;
-		case PM_LOG_ERROR:
-			asprintf(string, _("error: %s"), msg);
-			break;
-		case PM_LOG_WARNING:
-			asprintf(string, _("warning: %s"), msg);
-			break;
-		case PM_LOG_FUNCTION:
-			asprintf(string, _("function: %s"), msg);
-			break;
-		default:
-			break;
+	if(isatty(fileno(stdout))) {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, "%s%s%s%s", colortab.red, _("error: "), colortab.none, msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, "%s%s%s%s", colortab.yellow, _("warning: "), colortab.none, msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
+	} else {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, _("error: %s"), msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, _("warning: %s"), msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
 	}
 	free(msg);
 
@@ -844,10 +877,10 @@
 			fprintf(stream, "debug: ");
 			break;
 		case PM_LOG_ERROR:
-			fprintf(stream, _("error: "));
+			color_fprintf(stream, COLOR_RED_ALL, _("error: "));
 			break;
 		case PM_LOG_WARNING:
-			fprintf(stream, _("warning: "));
+			color_fprintf(stream, COLOR_YELLOW_ALL, _("warning: "));
 			break;
 		case PM_LOG_FUNCTION:
 		  /* TODO we should increase the indent level when this occurs so we can see
@@ -885,4 +918,310 @@
 }
 #endif
 
+/* pacman-color */
+
+int _set_color_sequence(const char* name, char* dest)
+{
+	int ret = 0;
+
+	if(strcmp(name, "black") == 0) {
+		strncpy(dest, "\033[0;30m", COLOR_LEN);
+	} else if(strcmp(name, "red") == 0) {
+		strncpy(dest, "\033[0;31m", COLOR_LEN);
+	} else if(strcmp(name, "green") == 0) {
+		strncpy(dest, "\033[0;32m", COLOR_LEN);
+	} else if(strcmp(name, "yellow") == 0) {
+		strncpy(dest, "\033[0;33m", COLOR_LEN);
+	} else if(strcmp(name, "blue") == 0) {
+		strncpy(dest, "\033[0;34m", COLOR_LEN);
+	} else if(strcmp(name, "magenta") == 0) {
+		strncpy(dest, "\033[0;35m", COLOR_LEN);
+	} else if(strcmp(name, "cyan") == 0) {
+		strncpy(dest, "\033[0;36m", COLOR_LEN);
+	} else if(strcmp(name, "white") == 0) {
+		strncpy(dest, "\033[0;37m", COLOR_LEN);
+	} else if(strcmp(name, "gray") == 0) {
+		strncpy(dest, "\033[1;30m", COLOR_LEN);
+	} else if(strcmp(name, "intensive red") == 0) {
+		strncpy(dest, "\033[1;31m", COLOR_LEN);
+	} else if(strcmp(name, "intensive green") == 0) {
+		strncpy(dest, "\033[1;32m", COLOR_LEN);
+	} else if(strcmp(name, "intensive yellow") == 0) {
+		strncpy(dest, "\033[1;33m", COLOR_LEN);
+	} else if(strcmp(name, "intensive blue") == 0) {
+		strncpy(dest, "\033[1;34m", COLOR_LEN);
+	} else if(strcmp(name, "intensive magenta") == 0) {
+		strncpy(dest, "\033[1;35m", COLOR_LEN);
+	} else if(strcmp(name, "intensive cyan") == 0) {
+		strncpy(dest, "\033[1;36m", COLOR_LEN);
+	} else if(strcmp(name, "intensive white") == 0) {
+		strncpy(dest, "\033[1;37m", COLOR_LEN);
+	} else if(strcmp(name, "intensive foreground") == 0) {
+		strncpy(dest, "\033[m\033[1m", COLOR_LEN);
+	} else if(strcmp(name, "none") == 0) {
+		strncpy(dest, "\033[m", COLOR_LEN);
+	} else {
+		ret = 1;
+	}
+	dest[COLOR_LEN] = '\0';
+	return(ret);
+}
+
+void _insert_color(FILE* stream, color_t color)
+{
+	switch(color) {
+		case COLOR_RED:
+			fprintf(stream, colortab.red);
+			break;
+		case COLOR_GREEN:
+			fprintf(stream, colortab.green);
+			break;
+		case COLOR_YELLOW:
+			fprintf(stream, colortab.yellow);
+			break;
+		case COLOR_BLUE:
+			fprintf(stream, colortab.blue);
+			break;
+		case COLOR_MAGENTA:
+			fprintf(stream, colortab.magenta);
+			break;
+		case COLOR_CYAN:
+			fprintf(stream, colortab.cyan);
+			break;
+		case COLOR_WHITE:
+			fprintf(stream, colortab.white);
+			break;
+		case COLOR_NONE:
+			fprintf(stream, colortab.none);
+			break;
+		default:;
+	}
+}
+
+int _parsecolorconfig(colortab_t* colortab, char* file)
+{
+	_set_color_sequence("intensive red", colortab->red);
+	_set_color_sequence("intensive green", colortab->green);
+	_set_color_sequence("intensive yellow", colortab->yellow);
+	_set_color_sequence("intensive blue", colortab->blue);
+	_set_color_sequence("intensive magenta", colortab->magenta);
+	_set_color_sequence("intensive cyan", colortab->cyan);
+	_set_color_sequence("intensive foreground", colortab->white);
+	_set_color_sequence("none", colortab->none);
+
+	FILE* fp = NULL;
+	int linenum = 0;
+	char line[PATH_MAX+1];
+	char* ptr;
+
+	fp = fopen(file, "r");
+	if(fp == NULL) {
+		pm_printf(PM_LOG_ERROR, _("config file %s could not be read.\n"), file);
+		return 1;
+	}
+	while(fgets(line, PATH_MAX, fp)) {
+		linenum++;
+		strtrim(line);
+
+		if(strlen(line) == 0 || line[0] == '#') {
+			continue;
+		}
+		if((ptr = strchr(line, '#'))) {
+			*ptr = '\0';
+		}
+
+		char* key = line;
+		ptr = line;
+		strsep(&ptr, "=");
+		strtrim(key);
+		strtrim(ptr);
+
+		if(key == NULL) {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: syntax error in config file- missing key.\n"),
+					file, linenum);
+			return 1;
+		}
+		if(strcmp(key, "Red") == 0) {
+			if(_set_color_sequence(ptr, colortab->red)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Green") == 0) {
+			if(_set_color_sequence(ptr, colortab->green)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Yellow") == 0) {
+			if(_set_color_sequence(ptr, colortab->yellow)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Blue") == 0) {
+			if(_set_color_sequence(ptr, colortab->blue)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Magenta") == 0) {
+			if(_set_color_sequence(ptr, colortab->magenta)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Cyan") == 0) {
+			if(_set_color_sequence(ptr, colortab->cyan)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "White") == 0) {
+			if(_set_color_sequence(ptr, colortab->white)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: directive '%s' not recognized.\n"),
+					file, linenum, key);
+			return(1);
+		}
+	}
+	return(0);
+}
+
+int parsecolorconfig()
+{
+	return(_parsecolorconfig(&colortab, "/etc/pacman.d/color.conf"));
+}
+
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args)
+{
+	int ret = 0;
+
+	if(isatty(fileno(stream)) && colors) {
+		char* msg = NULL;
+		ret = vasprintf(&msg, format, args);
+		if(msg == NULL) {
+			return(ret);
+		}
+
+		const colordata_t* colorpos = colors;
+		color_t colorlast = COLOR_NONE;
+		int len = strlen(msg) + 1;
+		wchar_t* wcstr = calloc(len, sizeof(wchar_t));
+		len = mbstowcs(wcstr, msg, len);
+		free(msg);
+		const wchar_t *strpos = wcstr;
+		
+		while(*strpos) {
+			if(colorpos->color != COLOR_END &&
+				((colorpos->separator == SEP_ANY) ||
+				 (colorpos->separator == SEP_LINE && *strpos == L'\n') ||
+				 (colorpos->separator == SEP_COLON && (*strpos == L':' || *strpos == L'：')))) {
+				_insert_color(stream, colorpos->color);
+				colorlast = colorpos->color;
+				colorpos++;
+			}
+			fprintf(stream, "%lc", (wint_t)*strpos);
+			strpos++;
+		}
+		free(wcstr);
+
+		if(colorlast != COLOR_NONE) {
+			_insert_color(stream, COLOR_NONE);
+		}
+	} else {
+		ret = vfprintf(stream, format, args);
+	}
+	return(ret);
+}
+
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stream, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+int color_printf(const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stdout, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string)
+{
+	if(title) {
+		color_printf(colors_title, "%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		color_printf(colors_string, "%s", string);
+	}
+	printf("\n");
+}
+
+const colordata_t COLOR_WHITE_ALL[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_GREEN_ALL[] = {
+	{ SEP_ANY, COLOR_GREEN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_RED_ALL[] = {
+	{ SEP_ANY, COLOR_RED },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_BLUE_ALL[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_YELLOW_ALL[] = {
+	{ SEP_ANY, COLOR_YELLOW },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_MAGENTA_ALL[] = {
+	{ SEP_ANY, COLOR_MAGENTA },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_CYAN_ALL[] = {
+	{ SEP_ANY, COLOR_CYAN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON2[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_WHITE_COLON[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_COLON, COLOR_SAME },
+	{ SEP_ANY, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
 /* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.4.1//src/pacman/util.h pacman-color-3.4.1//src/pacman/util.h
--- pacman-3.4.1//src/pacman/util.h	2010-06-24 15:23:29.000000000 +0200
+++ pacman-color-3.4.1//src/pacman/util.h	2010-09-12 09:56:57.193333335 +0200
@@ -37,6 +37,48 @@
 /* update speed for the fill_progress based functions */
 #define UPDATE_SPEED_SEC 0.2f
 
+/* pacman-color */
+typedef enum _separator_t {
+	SEP_ANY = 0,
+	SEP_LINE,
+	SEP_COLON,
+} separator_t;
+
+typedef enum _color_t {
+	COLOR_END = 0,
+	COLOR_SAME,
+	COLOR_RED,
+	COLOR_GREEN,
+	COLOR_YELLOW,
+	COLOR_BLUE,
+	COLOR_MAGENTA,
+	COLOR_CYAN,
+	COLOR_WHITE,
+	COLOR_NONE,
+} color_t;
+
+typedef struct _colordata_t {
+	separator_t separator;
+	color_t color;
+} colordata_t;
+
+extern const colordata_t COLOR_WHITE_ALL[];
+extern const colordata_t COLOR_GREEN_ALL[];
+extern const colordata_t COLOR_RED_ALL[];
+extern const colordata_t COLOR_BLUE_ALL[];
+extern const colordata_t COLOR_YELLOW_ALL[];
+extern const colordata_t COLOR_MAGENTA_ALL[];
+extern const colordata_t COLOR_CYAN_ALL[];
+extern const colordata_t COLOR_DOUBLECOLON[];
+extern const colordata_t COLOR_DOUBLECOLON2[];
+extern const colordata_t COLOR_WHITE_COLON[];
+
+int parsecolorconfig();
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...) __attribute__((format(printf,3,4)));
+int color_printf(const colordata_t* colors, const char* format, ...) __attribute__((format(printf,2,3)));
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args) __attribute__((format(printf,3,0)));
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string);
+
 int trans_init(pmtransflag_t flags);
 int trans_release(void);
 int needs_root(void);
@@ -49,15 +91,15 @@
 char *strtrim(char *str);
 char *strreplace(const char *str, const char *needle, const char *replace);
 alpm_list_t *strsplit(const char *str, const char splitchar);
-void string_display(const char *title, const char *string);
-void list_display(const char *title, const alpm_list_t *list);
-void list_display_linebreak(const char *title, const alpm_list_t *list);
+void string_display(const colordata_t *colors_title, const char *title, const char *string);
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
 void display_targets(const alpm_list_t *pkgs, int install);
 void display_new_optdepends(pmpkg_t *oldpkg, pmpkg_t *newpkg);
 void display_optdepends(pmpkg_t *pkg);
 void print_packages(const alpm_list_t *packages);
-int yesno(char *fmt, ...);
-int noyes(char *fmt, ...);
+int yesno(const colordata_t *colors, char *fmt, ...);
+int noyes(const colordata_t *colors, char *fmt, ...);
 int pm_printf(pmloglevel_t level, const char *format, ...) __attribute__((format(printf,2,3)));
 int pm_fprintf(FILE *stream, pmloglevel_t level, const char *format, ...) __attribute__((format(printf,3,4)));
 int pm_vfprintf(FILE *stream, pmloglevel_t level, const char *format, va_list args) __attribute__((format(printf,3,0)));
